#!/usr/bin/env python3
"""Scenario definitions for multi-scenario hyperparameter tuning.

The goal is to evaluate TuningParams across a diverse set of game setups so
results generalize rather than overfitting to one catalog/mission/step budget.

Uses all-pairs (pairwise) combinatorial testing to cover 4 dimensions with
only 24 rows instead of the full 144-row Cartesian product:

  Dimension     Values                                                Count
  ----------    -------------------------------------------------     -----
  Catalog       WTC Set, GW Misc, Omnium Gatherum                       3
  Symmetry      False, True                                              2
  Mission       Hammer and Anvil, Dawn of War, Tipping Point,            6
                Sweeping Engagement, Crucible of Battle,
                Search and Destroy
  Step count    10, 20, 50, 100                                          4

The 24-row covering array guarantees every pair of values from any two
dimensions appears at least once (80 pairs total). This is constructed via:
  catalog  = CATALOGS[(mission_idx + steps_idx) % 3]
  symmetry = (mission_idx + steps_idx) % 2 == 1

Each scenario also includes per-catalog feature-count preferences (e.g. WTC
wants 1-2 obstacles and 5-8 obscuring) and shared scoring targets that match
the UI defaults.

Exported:
  CATALOGS, MISSIONS, STEP_COUNTS  — dimension value lists
  COVERING_ARRAY  — the 24 (catalog, symmetric, mission, steps) tuples
  CATALOG_PREFERENCES, SCORING_TARGETS  — engine config dicts
  build_scenarios()  — returns 24 complete engine param dicts (minus seed/tuning)
"""

import sys
from pathlib import Path

SCRIPT_DIR = Path(__file__).resolve().parent
V2_DIR = SCRIPT_DIR.parent
sys.path.insert(0, str(V2_DIR))

from frontend.catalogs import TERRAIN_CATALOGS  # noqa: E402
from frontend.missions import find_mission_path, get_mission  # noqa: E402

# ---------------------------------------------------------------------------
# Dimension values
# ---------------------------------------------------------------------------

CATALOGS = ["WTC Set", "GW Misc", "Omnium Gatherum"]
MISSIONS = [
    "Hammer and Anvil",
    "Dawn of War",
    "Tipping Point",
    "Sweeping Engagement",
    "Crucible of Battle",
    "Search and Destroy",
]
STEP_COUNTS = [10, 20, 50, 100]

# ---------------------------------------------------------------------------
# 24-row all-pairs covering array
# (catalog_name, symmetric, mission_name, num_steps)
#
# Generated by: catalog = (m + s) % 3, symmetry = (m + s) % 2
# where m = mission index (0..5), s = step-count index (0..3).
# This covers all 80 pairwise combinations across the 4 dimensions.
# ---------------------------------------------------------------------------

COVERING_ARRAY: list[tuple[str, bool, str, int]] = [
    (CATALOGS[(m + s) % 3], (m + s) % 2 == 1, MISSIONS[m], STEP_COUNTS[s])
    for m in range(len(MISSIONS))
    for s in range(len(STEP_COUNTS))
]

# ---------------------------------------------------------------------------
# Per-catalog feature count preferences
# ---------------------------------------------------------------------------

CATALOG_PREFERENCES: dict[str, list[dict]] = {
    "WTC Set": [
        {"feature_type": "obstacle", "min": 1, "max": 2},
        {"feature_type": "obscuring", "min": 5, "max": 8},
    ],
    "GW Misc": [
        {"feature_type": "obstacle", "min": 0, "max": 0},
        {"feature_type": "obscuring", "min": 3, "max": 5},
    ],
    "Omnium Gatherum": [
        {"feature_type": "obstacle", "min": 1, "max": 2},
        {"feature_type": "obscuring", "min": 4, "max": 8},
    ],
}

# Scoring targets (same for all scenarios — matches UI defaults)
SCORING_TARGETS = {
    "overall_visibility_target": 30.0,
    "overall_visibility_weight": 1.0,
    "dz_visibility_target": 20.0,
    "dz_visibility_weight": 1.0,
    "dz_hidden_target": 70.0,
    "dz_hidden_weight": 5.0,
    "objective_hidability_target": 50.0,
    "objective_hidability_weight": 5.0,
}


def build_scenarios(
    table_width: float = 60.0,
    table_depth: float = 44.0,
    num_replicas: int = 4,
) -> list[dict]:
    """Build 24 scenario dicts from the all-pairs covering array.

    Each dict is a complete engine params set including num_steps.
    Only seed and tuning are left for the caller to fill in.
    Includes ``_scenario_name`` and ``_num_steps`` metadata keys.
    """
    scenarios = []
    for idx, (catalog_name, symmetric, mission_name, num_steps) in enumerate(
        COVERING_ARRAY
    ):
        catalog = TERRAIN_CATALOGS[catalog_name]
        mission_path = find_mission_path(mission_name)
        assert mission_path is not None, f"Mission not found: {mission_name}"
        edition, pack, deployment = mission_path
        mission = get_mission(
            edition, pack, deployment, table_width, table_depth
        )
        assert mission is not None

        sym_label = "sym" if symmetric else "nosym"
        short_mission = mission_name.replace(" ", "")
        short_catalog = catalog_name.replace(" ", "")
        scenario_name = f"s{idx:02d}_{short_catalog}_{sym_label}_{short_mission}_s{num_steps}"

        params = {
            "_scenario_name": scenario_name,
            "table_width_inches": table_width,
            "table_depth_inches": table_depth,
            "num_steps": num_steps,
            "num_replicas": num_replicas,
            "swap_interval": 20,
            "max_temperature": 50.0,
            "min_feature_gap_inches": 3.0,
            "min_edge_gap_inches": 2.0,
            "catalog": catalog,
            "mission": mission,
            "symmetric": symmetric,
            "feature_count_preferences": CATALOG_PREFERENCES[catalog_name],
            "scoring_targets": SCORING_TARGETS,
        }
        scenarios.append(params)

    return scenarios

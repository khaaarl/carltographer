"""Hash manifest for engine parity certification.

When comparison tests pass, this module creates a hash manifest file that
certifies the Python engine source code has been verified to work identically
to the Rust engine. The frontend uses this to auto-select which engine to use.
"""

import hashlib
import json
import sys
from pathlib import Path

PYTHON_ENGINE_DIR = Path(__file__).parent.parent / "engine"
MANIFEST_FILE = Path(__file__).parent.parent / ".engine_parity_manifest.json"


def _discover_engine_files() -> list[str]:
    """Discover all Python engine source files to hash.

    Returns relative filenames (from engine directory) of all .py files
    that are not test files or in __pycache__, sorted for determinism.

    Raises FileNotFoundError if engine directory doesn't exist.
    """
    if not PYTHON_ENGINE_DIR.exists():
        raise FileNotFoundError(
            f"Python engine directory not found: {PYTHON_ENGINE_DIR}"
        )

    engine_files = []
    for py_file in sorted(PYTHON_ENGINE_DIR.rglob("*.py")):
        # Skip test files and cache
        if py_file.name.endswith("_test.py"):
            continue
        if "__pycache__" in py_file.parts:
            continue

        # Get relative path from engine directory
        rel_path = py_file.relative_to(PYTHON_ENGINE_DIR).as_posix()
        engine_files.append(rel_path)

    return engine_files


def compute_file_hash(file_path: Path) -> str:
    """Compute SHA256 hash of a file."""
    sha256_hash = hashlib.sha256()
    with open(file_path, "rb") as f:
        for byte_block in iter(lambda: f.read(4096), b""):
            sha256_hash.update(byte_block)
    return sha256_hash.hexdigest()


def compute_engine_hashes() -> dict[str, str]:
    """Compute hashes for all Python engine files.

    Discovers all .py files in the engine directory (excluding test files
    and __pycache__), computes SHA256 hashes, and returns as a sorted dict.
    """
    hashes = {}
    for rel_path in _discover_engine_files():
        file_path = PYTHON_ENGINE_DIR / rel_path
        if file_path.exists():
            hashes[rel_path] = compute_file_hash(file_path)
    return hashes


def write_manifest(hashes: dict[str, str]) -> None:
    """Write hash manifest to file."""
    manifest = {
        "version": "1",
        "description": (
            "This manifest certifies that the Rust engine has been verified "
            "to produce bit-identical output to the Python engine at this state. "
            "Generated by engine_cmp/compare.py after all comparison tests pass."
        ),
        "engine_files": hashes,
    }
    with open(MANIFEST_FILE, "w") as f:
        json.dump(manifest, f, indent=2)


def read_manifest() -> dict[str, str] | None:
    """Read existing hash manifest, returns None if file doesn't exist."""
    if not MANIFEST_FILE.exists():
        return None
    try:
        with open(MANIFEST_FILE) as f:
            data = json.load(f)
        return data.get("engine_files", {})
    except (json.JSONDecodeError, IOError):
        return None


def verify_engine_unchanged() -> bool:
    """Check if Python engine source matches the certified hashes.

    Returns True if:
    1. Running inside a PyInstaller bundle (parity was certified at build time), OR
    2. Manifest file exists, AND
    3. All discovered Python engine files match their certified hashes

    Returns False if:
    1. Manifest file doesn't exist, OR
    2. Any Python engine file has changed, OR
    3. Any discovered file is missing from manifest, OR
    4. Any manifest file is no longer in engine directory
    """
    # In a PyInstaller bundle, source files are compiled to bytecode â€” rglob
    # finds nothing, verification fails. The packaging script runs
    # build-rust-engine.sh (which certifies parity) before packaging, so the
    # Rust engine is guaranteed correct.
    if getattr(sys, "frozen", False):
        return True

    manifest_hashes = read_manifest()
    if manifest_hashes is None:
        return False

    current_hashes = compute_engine_hashes()

    # Check that the set of files matches
    if set(manifest_hashes.keys()) != set(current_hashes.keys()):
        return False

    # Check all files match their hashes
    for filename, manifest_hash in manifest_hashes.items():
        if manifest_hash != current_hashes[filename]:
            return False

    return True
